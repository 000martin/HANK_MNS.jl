<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Replication of McKay, Nakamura, and Steinsson (2016) · HANK_MNS.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">HANK_MNS.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Replication of McKay, Nakamura, and Steinsson (2016)</a><ul class="internal"><li><a class="tocitem" href="#How-does-it-work?"><span>How does it work?</span></a></li><li><a class="tocitem" href="#Function-documentation"><span>Function documentation</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Replication of McKay, Nakamura, and Steinsson (2016)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Replication of McKay, Nakamura, and Steinsson (2016)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/000martin/HANK_MNS.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Replication-of-McKay,-Nakamura,-and-Steinsson-(2016)"><a class="docs-heading-anchor" href="#Replication-of-McKay,-Nakamura,-and-Steinsson-(2016)">Replication of McKay, Nakamura, and Steinsson (2016)</a><a id="Replication-of-McKay,-Nakamura,-and-Steinsson-(2016)-1"></a><a class="docs-heading-anchor-permalink" href="#Replication-of-McKay,-Nakamura,-and-Steinsson-(2016)" title="Permalink"></a></h1><p>This is a replication of <a href="https://www.aeaweb.org/articles?id=10.1257/aer.20150063">&quot;The Power of Forward Guidance&quot;</a> by Alisdair McKay, Emi Nakamura, and Jón Steinsson (henceforth MNS).</p><p>Authors: @mhaense1, @000martin</p><p>The project was part of our evaluation for the course <a href="https://floswald.github.io/NumericalMethods/">Numerical Methods</a> at SciencesPo Paris in Spring 2021. </p><p>The original paper studies the Forward Guidance, an unconventionary monetary tool, which, in standard  representative agent New Keynesian models, has strong effects on current economic outcomes.</p><p>However, as MNS (and we using their model) find, Forward Guidance has considerably less power in models with heterogenous agents facing unisurable idiosyncratic income risk. </p><p>Conceptually, MNS compute perfect foresight transition paths of their simple Heterogenous Agents New Keynesian (HANK) model following a one-time announcement of an interest change far in the future (20 quarters in the paper).</p><p>Our Julia code is able to replicate their main exercises and produce equivalents of Figures 3,4,5 and 6 as well as Table 2 in their paper. Unfortunalety, it does not (yet) extend to their Zero Lower Bound Analysis featuring time-varying subjective discount factors (Section II.C in the paper).</p><h2 id="How-does-it-work?"><a class="docs-heading-anchor" href="#How-does-it-work?">How does it work?</a><a id="How-does-it-work?-1"></a><a class="docs-heading-anchor-permalink" href="#How-does-it-work?" title="Permalink"></a></h2><p>In case you want to simply reproduce these main results, you use our convenience functions, which allow you to obtain the results as simple as follows:</p><pre><code class="language-julia">
using HANK_MNS

#Displays our replications of figures 3 and 4
get_figures_3_4()

#Saves a table containing our replication of table 2 
tb2 = get_table_2()

#Displays our replications of figures 5 and 6
#This may take quite a while, since ~20 transition paths must be computed
get_figures_5_6()
</code></pre><p>These convenience functions can also take inputs, allowing to analyze different time horizons or rate changes. See the documentation below for details.</p><p>In case one wants to produce a transition path with a custom calibration using the incomplete contracts model, one would proceed as follows:</p><pre><code class="language-julia">using HANK_MNS

#Example: choose a higher aggregate asset level and higher income risk
p = set_parameters(B = 7.8, σ = 0.03^0.5)

#Find the \beta consistent with the target interest rate and asset level in steady state
#and obtain a corresponding steady state structure SS.
#Depending on your calibration, you might have to choose a different betaRange,
#e.g [0.97,0.995] instead of [0.95,0.99]. See function documentation for details. 
b, y, SS = get_steady_state(p,0.9,[0.95,0.99])

#set the correct \beta value
p.β = b

#obtain the transition path for the announcemnt of a 22 quarter ahead interest rate reduction of 60 basis points.
trp = get_transition_full(;TR = 22, RChange = -0.006)

#trp is a structure containing the transition paths for, amongst others, aggregate output, inflation and the wage rate.
#Make a table, plot it,...</code></pre><h2 id="Function-documentation"><a class="docs-heading-anchor" href="#Function-documentation">Function documentation</a><a id="Function-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Function-documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.params" href="#HANK_MNS.params"><code>HANK_MNS.params</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">A structure that stores the parameter vector of the model, including all grids.
It can be automatically generayed using function `set_parameters()`.
It contains the following elements: 
..* The discount factor `β` 
..* The CRRA risk aversion parameter `γ` 
..* Yhe inverse Frisch elasticity `ψ`
..* The labor disutility scaling parameter `ψ1` (only used in complete markets case)
..* The target asset level `B`
..* The markup/CES production function parameter `μ`
..* The Calvo price re-set probability `θ`
..* The target interest rate `Rbar`
..* The number of grid points on the labor productivity grid `nz`
..* The labor productivity grid `z`
..* The labor productivity state Markov transition matrix `Πz`
..* The invariant distribution over labor productivty states `Γ`
..* The tax weights `tax_weights`
..* The borrowing constraint `a_min`
..* The maximum value on the asset grid `a_max`
..* The number of points on the asset grid used for computing the wealth distribution `nk` 
..* The number of points on the asset grid used for computing HH policy functions `nb` 
..* The asset grid used for computing the wealth distribution `k_grid`
..* The asset grid used for computing the HH policy functions `b_grid`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/structs.jl#L8-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.steady_state" href="#HANK_MNS.steady_state"><code>HANK_MNS.steady_state</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">A structure that saves the steady state of the incomplete markets model.
It contains the household policy functions (`c_polcicies`), the invariant distribution of wealth (`D`),
output (`Y`), consumption (`C`), hours worked (`L`), aggregate assets (`K`), the wage (`w`), the tax rate (`τ`),
the dividebd (`div`) and the interest rate (`Rbar`). Note that `C`, `L` and `Y` should be equal (approximately).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/structs.jl#L56-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.transition_CompMkts" href="#HANK_MNS.transition_CompMkts"><code>HANK_MNS.transition_CompMkts</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">A structure that stores the complete markets transition path, including the time paths of price dispersion (`S`), the wage (`w`),
inflation (`pΠ`), output (`Y`), the interest rate (`R`),  and the dividend (`div`).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/structs.jl#L92-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.transition_full" href="#HANK_MNS.transition_full"><code>HANK_MNS.transition_full</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">A structure that stores the incomplete markets model transition path, including the time paths of price dispersion (`S`), the wage (`w`),
inflation (`pΠ`), output (`Y`), the interest rate (`R`), the tax rate (`τ`) and the dividend (`div`).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/structs.jl#L77-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.EGM-Tuple{Matrix{Float64}, Float64, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, params}" href="#HANK_MNS.EGM-Tuple{Matrix{Float64}, Float64, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, params}"><code>HANK_MNS.EGM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">EGM(c_next::Array{Float64,2},β::Float64, Rs::Array{Float64,1}, ws::Array{Float64,1},
τs::Array{Float64,1}, div::Array{Float64,1},p::params)</code></pre><p>Conducts one iteration on consumption and labor supply using the endogenous grid method (EGM). Inputs need to be 2x1 arrays of wage, interest, etc. for the current and next period, as well  as the HH policy function <code>c_next</code> for the next period (or iteration).</p><p>This function is used in the function <code>solveback</code> calls <code>get_cnbp</code> as well as <code>egm_solve_constrained</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/steady_state.jl#L281-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.EGM_SS-Tuple{Matrix{Float64}, Float64, Float64, params}" href="#HANK_MNS.EGM_SS-Tuple{Matrix{Float64}, Float64, Float64, params}"><code>HANK_MNS.EGM_SS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">EGM_SS(c_guess::Array{Float64,2}, β::Float64,Y::Float64, p::params; T::Int=30, 
       maxit::Int = 500, tol::Float64 = 1e-7)</code></pre><p>Using an initial guess <code>c_guess</code>, discount factor <code>eta</code>, aggregate output level <code>Y</code>  and parameter structure <code>p</code>, this function computes the  household consumption policy functions, using the function <code>solveback</code>.</p><p>Note that steady state factor prices can be computed from <code>Y</code> and don&#39;t need to be supplied separately.</p><p>The default values for <code>T</code> (the number of times policy function is iterated over during the <code>solveback</code> call), <code>maxit</code>  (maximum number of iterations) and <code>tol</code> (tolerance value for convergence) are as in the MNS paper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/steady_state.jl#L154-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.aggregate_C_L-Tuple{Vector{Float64}, Matrix{Float64}, Float64, Float64, Float64, Float64, params}" href="#HANK_MNS.aggregate_C_L-Tuple{Vector{Float64}, Matrix{Float64}, Float64, Float64, Float64, Float64, params}"><code>HANK_MNS.aggregate_C_L</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">aggregate_C_L(D::Array{Float64,1}, c_policies::Array{Float64,1}, R::Float64, 
              w::Float64, τ::Float64, div::Float64)</code></pre><p>Given wealth distribution <code>D</code> and HH consumption policy function <code>c_policies</code> as well as factor prices, this function computes the implied consumption and labor supply of the household sector.</p><p>The function uses the function <code>get_cnbp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/steady_state.jl#L506-L514">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.check_steady_state-Tuple{Float64, Float64, params}" href="#HANK_MNS.check_steady_state-Tuple{Float64, Float64, params}"><code>HANK_MNS.check_steady_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_steady_state(β::Float64,Y::Float64,p::params,return_distance::Bool=false)</code></pre><p><strong>NOTE: This function is not used in the current implemenation of the model, so it is not extensively documented.</strong></p><p>For given β, Y and parameters, this function computes consumption and labor suppy  as implied by the household decisions and returns the distance between output  implied by labor and output implied by consumption as well as the distance between household asset choices and the asset target.  It can be used in an Root-Finding algorithm to find the β corresponding to the asset and interest rate targets, as in the MNS code.</p><p>However, we chose to use a simpler bisection algorithm as in <code>get_steady_state</code> instead. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/steady_state.jl#L96-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.egm_solve_constrained-Tuple{Vector{Float64}, Int64, Float64, Float64, Float64, Float64, params}" href="#HANK_MNS.egm_solve_constrained-Tuple{Vector{Float64}, Int64, Float64, Float64, Float64, Float64, params}"><code>HANK_MNS.egm_solve_constrained</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">egm_solve_constrained(bs::Array{Float64,1},ip::Int,w::Float64,τ::Float64,
                      div::Float64,R::Float64,p::params)</code></pre><p>Backs out consumption level of constrained household using the same iterative procedure as MNS. Used in the function <code>EGM</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/steady_state.jl#L346-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.find_closest_lower-Tuple{Float64, Vector{Float64}}" href="#HANK_MNS.find_closest_lower-Tuple{Float64, Vector{Float64}}"><code>HANK_MNS.find_closest_lower</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_closest_lower(x::Float64,grid::Array{Float64,1})</code></pre><p>Helper function for <code>lineartrans</code>. For a given savings choice <code>x</code>, it finds the nearest point  on the asset <code>grid</code> that is lower or equal than <code>x</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/steady_state.jl#L478-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.forward_dist-Tuple{Vector{Float64}, SparseArrays.SparseMatrixCSC}" href="#HANK_MNS.forward_dist-Tuple{Vector{Float64}, SparseArrays.SparseMatrixCSC}"><code>HANK_MNS.forward_dist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">forward_dist(D::Array{Float64,1},Pi::SparseMatrixCSC)</code></pre><p>Calculates asset distribution in next period given transition matrix <code>Pi</code> and current distribution <code>D</code>. This is just multiplying a (sparse) matrix with a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/transition_full.jl#L225-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.forwardmat-Tuple{Matrix{Float64}, Float64, Float64, Float64, Float64, params}" href="#HANK_MNS.forwardmat-Tuple{Matrix{Float64}, Float64, Float64, Float64, Float64, params}"><code>HANK_MNS.forwardmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">forwardmat(c_opt::Array{Float64,2},R::Float64,w::Float64,τ::Float64,div::Float64)</code></pre><p>Generates a (sparse) transition matrix for the aggregate wealth distribution, using the household policy function and factor prices.</p><p>Uses the helper functions <code>get_cnbp</code> and <code>lineartrans</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/steady_state.jl#L385-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.get_cnbp-Tuple{Vector{Float64}, Matrix{Float64}, Float64, Float64, Float64, Float64, Int64, params}" href="#HANK_MNS.get_cnbp-Tuple{Vector{Float64}, Matrix{Float64}, Float64, Float64, Float64, Float64, Int64, params}"><code>HANK_MNS.get_cnbp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_cnbp(xthis::Array{Float64},c::Array{Float64},R::Float64,w::Float64,
         τ::Float64,p::params,inc_idx::Int)</code></pre><p>Helper function that, given the HH policy function and factor prices, taxes, etc., interpolates the HH policy function for an agent income state <code>inc_idx</code> to the values in <code>xthis</code> and computes corresponding labor supply and savings.</p><p>Returns interpolated consumption policies <code>c</code> and correspoding labor supply <code>n</code> and savings <code>bp</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/steady_state.jl#L254-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.get_figures_3_4-Tuple{}" href="#HANK_MNS.get_figures_3_4-Tuple{}"><code>HANK_MNS.get_figures_3_4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_figures_3_4(;TR::Int64 = 20, T::Int64 = 200, RChange::Float64 = -0.005)</code></pre><p>Convenience function that replicates Figures 3 and 4 from the MNS paper.</p><p>Just running <code>get_figures_3_4()</code> will display equivalents to Figures 3 and 4 in the MNS paper.</p><p>The function relies on <code>set_parameters</code>, <code>get_steady_state</code>, <code>get_transition_full</code> and <code>get_transition_CompMkts</code>.</p><p>Optional argument: Time horizon of interest rate change (TR). Size of interest rate change (RChange)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/paper_results.jl#L4-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.get_figures_5_6-Tuple{}" href="#HANK_MNS.get_figures_5_6-Tuple{}"><code>HANK_MNS.get_figures_5_6</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_figures_5_6(; Horizon::StepRange{Int64,Int64} = 1:2:41, T::Int64 = 200, RChange::Float64 = -0.005)</code></pre><p>Convenience function that replicates Figures 5 and 6 from the MNS paper.</p><p>Just running <code>get_figures_5_6()</code> will display equivalents to Figures 5 and 6 in the MNS paper.</p><p>The function relies on <code>set_parameters</code>, <code>get_steady_state</code>, <code>get_transition_full</code> and <code>get_transition_CompMkts</code>.</p><p>Optional argument:  ..* Horizons of interest rate changes to consider (<code>Horizon</code>), to be supplied as <code>StepRange</code>. ..* Total length of transition period to compute (<code>T</code>), i.e. assuming that after T periods economy will be back in SS ..* Size of interest rate change (RChange).</p><p>All default values corresppond to the values used by MNS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/paper_results.jl#L48-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.get_steady_state-Tuple{params, Float64, Vector{Float64}}" href="#HANK_MNS.get_steady_state-Tuple{params, Float64, Vector{Float64}}"><code>HANK_MNS.get_steady_state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_steady_state(p::params,Y_guess::Float64,beta_Range::Array{Float64,1};tolβ::Float64=1e-6,tolY::Float64=1e-6)</code></pre><p>Finds the steady state for given a target interest rate and asset level (conatined in the parameter structure <code>p</code>)  by iterating over β, using a simple bisection type updating algorithm.</p><p>It calls the function <code>EGM_SS</code>, <code>forwardmat</code>, <code>inv_dist</code> and <code>aggregate_C_L</code>.</p><p>For the biscetion algorithm, it is necessary to supply and upper and lower bound for β as <code>betaRange</code>, so that aggregate household savings are higher than the target asset level for the upper bound and lower for the lower bound. </p><p>I typically used Y = 0.6 as guess for Y and <code>beta_Range = [0.95,0.99]</code> for the baseline calibration and <code>[0.97,0.995]</code>  for the high asset calibration, which works fine. Y_guess not particularly important, I typically use 0.6 as do MNS.</p><p>The function returns the value of β that is consistent with a steady state with the target interest rate and asset level, the output level of said steady state and a <code>steady_state</code> structure.</p><p>The default tolerance levels are as in the MNS paper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/steady_state.jl#L7-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.get_table_2-Tuple{}" href="#HANK_MNS.get_table_2-Tuple{}"><code>HANK_MNS.get_table_2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_table_2(;Horizon::Int=20,T::Int=200,RChange::Float64 = -0.005)</code></pre><p>Convenience function that replicates Table 2 from the MNS paper.</p><p>Just running <code>get_table_2()</code> will return an equivalent to Table 2 as a table object.</p><p>The function relies on <code>set_parameters</code>, <code>get_steady_state</code>, <code>get_transition_full</code> and <code>get_transition_CompMkts</code>.</p><p>Optional argument:  ..* Time horizon of interest rate change (<code>TR</code>) ..* Total length of transition period to compute (<code>T</code>), i.e. assuming that after T periods economy will be back in SS  ..* Size of interest rate change (<code>RChange</code>)</p><p>Default values correspond to the values chosen by MNS.</p><p><strong>Note: The returned values will not be identical to the ones obtained by MNS.</strong></p><p><strong>However, notice that chosen unit is Basis Points (=0.01 percent), so the actual numerical difference between the MNS solution and ours is small.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/paper_results.jl#L114-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.get_transition_CompMkts-Tuple{Int64, Int64, params}" href="#HANK_MNS.get_transition_CompMkts-Tuple{Int64, Int64, params}"><code>HANK_MNS.get_transition_CompMkts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_transition_CompMkts(TR::Int, T::Int, p::params; RChange::Float64 = -0.005)</code></pre><p>Solves for the complete markets transition path. Inputs: TR (time until single-quarter interest rate change), T (time horizon transition path),  (Change of R at time TR))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/complete_markets.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.get_transition_full-Tuple{Int64, Int64, params, steady_state}" href="#HANK_MNS.get_transition_full-Tuple{Int64, Int64, params, steady_state}"><code>HANK_MNS.get_transition_full</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_transition_full(TR::Int64,T::Int64,p::params,SS::steady_state; RChange::Float64 = -0.005)</code></pre><p>Convenience function to solve for a transition path. Relies on function <code>solve_for_transition</code>. </p><p>Always uses the steady state factor prices, price dispersion, etc. as initial guess for the transition path.</p><p>Inputs: <code>TR</code> (time until single-quarter interest rate change), <code>T</code> (time horizon transition path),  <code>p</code> (parameter structure), <code>SS</code> (steady state structure), <code>RChange</code> (Change of R at time TR). The default <code>RChange</code> value corresponds to the 50 basis points decrease considered in the MNS paper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/transition_full.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.inv_dist-Tuple{SparseArrays.SparseMatrixCSC}" href="#HANK_MNS.inv_dist-Tuple{SparseArrays.SparseMatrixCSC}"><code>HANK_MNS.inv_dist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inv_dist(Π::SparseMatrixCSC)</code></pre><p>Find invariant steady state wealth distribution by solving for the eigenvector corresponding to the  unit eigenvalue of the (sparse) wealth transition matrix. </p><p>The idea for a procedure to do this efficiently was taken from the   <a href="https://discourse.julialang.org/t/stationary-distribution-with-sparse-transition-matrix/40301">following discussion in the Julia forum</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/steady_state.jl#L489-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.lineartrans-Tuple{Vector{Float64}, params}" href="#HANK_MNS.lineartrans-Tuple{Vector{Float64}, params}"><code>HANK_MNS.lineartrans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lineartrans(bp::Array{Float64,1},par::params)</code></pre><p>Calculates the new positions and transition probabilities on the asset grid for given savings choices. Used the to conduct a non-stochastic simulation procedure for the wealth distribution a la Young (2010, JEDC).</p><p>Uses the helper function <code>find_closest_lower</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/steady_state.jl#L444-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.logspaceshift-Tuple{Float64, Float64, Int64, Float64, Float64}" href="#HANK_MNS.logspaceshift-Tuple{Float64, Float64, Int64, Float64, Float64}"><code>HANK_MNS.logspaceshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logspaceshift(xa::Float64,xb::Float64,n::Int,x2::Float64,n_at_x2::Float64)</code></pre><p>A function involved in replicating a log-spaced asset grids exactly as in the MNS code. Several methdos available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/structs.jl#L106-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.logspaceshift-Tuple{Float64, Float64, Int64, Float64}" href="#HANK_MNS.logspaceshift-Tuple{Float64, Float64, Int64, Float64}"><code>HANK_MNS.logspaceshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logspaceshift(xa::Float64,xb::Float64,n::Int,x2::Float64)</code></pre><p>A function involved in replicating a log-spaced asset grids exactly as in the MNS code. Several methdos available. This is one of them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/structs.jl#L124-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.logspaceshift-Tuple{Float64, Float64, Int64}" href="#HANK_MNS.logspaceshift-Tuple{Float64, Float64, Int64}"><code>HANK_MNS.logspaceshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logspaceshift(xa::Float64,xb::Float64,n::Int)</code></pre><p>A function involved in replicating a log-spaced asset grids exactly as in the MNS code. Several methdos available. This is one of them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/structs.jl#L140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.makeknotd-Tuple{Float64, Float64, Int64, Float64}" href="#HANK_MNS.makeknotd-Tuple{Float64, Float64, Int64, Float64}"><code>HANK_MNS.makeknotd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makeknotd(kmin::Float64,kmax::Float64,n::Int,logshift::Float64)</code></pre><p>A Function that produces an asset grid using the function <code>logspaceshift</code>. Several methods available. This is one of them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/structs.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.makeknotd-Tuple{Float64, Float64, Int64}" href="#HANK_MNS.makeknotd-Tuple{Float64, Float64, Int64}"><code>HANK_MNS.makeknotd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makeknotd(kmin::Float64,kmax::Float64,n::Int,logshift::Float64)</code></pre><p>A Function that produces an asset grid using the function <code>logspaceshift</code>. Several methods available. This os one of them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/structs.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.margU" href="#HANK_MNS.margU"><code>HANK_MNS.margU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">margU(c::Float64,par::params,order::Int64=1)</code></pre><p>Helper function, computes marginal utility of consumption or second derivative of utility function (if order = 2).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/steady_state.jl#L238-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.reshape_c-Tuple{Matrix{Float64}, params}" href="#HANK_MNS.reshape_c-Tuple{Matrix{Float64}, params}"><code>HANK_MNS.reshape_c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reshape_c(c::Array{Float64,2},par::params)</code></pre><p>Helper functions that gets the HH consumption policy functions into a different form. If they are supplied as a <code>nb*nz</code> matrix, they  will be turned into a vector of length <code>nb+nz</code> and vice versa. This is the method doing the former.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/structs.jl#L260-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.reshape_c-Tuple{Vector{Float64}, params}" href="#HANK_MNS.reshape_c-Tuple{Vector{Float64}, params}"><code>HANK_MNS.reshape_c</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reshape_c(c::Array{Float64},p::params)</code></pre><p>Helper functions that gets the HH consumption policy functions into a different form. If they are supplied as a <code>nb*nz</code> matrix, they  will be turned into a vector of length <code>nb+nz</code> and vice versa. This is the method doing the latter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/structs.jl#L245-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.set_parameters-Tuple{}" href="#HANK_MNS.set_parameters-Tuple{}"><code>HANK_MNS.set_parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_parameters(;β::Float64 = 0.986,    # Discount factor
                γ::Float64 = 2.0,      # Risk aversion
                ψ::Float64 = 2.0,      # Inverse Frisch elasticity
                ψ1::Float64 = 1.0,     # Labor disutility scaling (only in complete markets)
                B::Float64 = 5.5,      # Supply of Assets: 1.4 times annual GDP = 5.6 times quarterly GDP
                μ::Float64 = 1.2,      # Mark-up
                θ::Float64 = 0.15,     # Probability that Calvo fairy visits
                Rbar::Float64 = 1.005, # Target quarterly interest rate
                nz::Int64 = 3,         # Number of income grid states
                ρ::Float64 = 0.96566,            # Persistence parameter income process
                σ::Float64 = 0.01695^0.5,        # Std of income process random comp
                tax_weights::Array{Float64,1} = [0.0,0.0,1.0],   # Tax weights
                a_min::Float64  = 0.0,           # Borrowing constraint
                a_max::Float64 =75.0,            # Maximum asset holdings in grid
                x_min::Float64 = 0.001,          # Parameter to generate the consumption knots
                nk::Int64 = 1000,                # Number of grid points used for quadrature grid
                nb::Int64 = 200)</code></pre><p>Function to construct the parameter structure. The default parameters correspond to the baseline calibration from the MNS paper. The function applies the Rouwenhorst method (using its <code>QuantEcon</code> implementation) to discretize the AR(1) process for (log) labor productivity with persistence ρ and innovation variance σ.     Note that while <code>eta</code> is set automatically, it will typically be replaced after the steady state is computed, since β is numerically computed to match a target interest rate and aggregate asset level.</p><p>To generate the asset grids, the functions <code>makeknotd</code> and <code>logspaceshift</code> are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/structs.jl#L180-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.simulate_forward-Tuple{Vector{Float64}, Matrix{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, params}" href="#HANK_MNS.simulate_forward-Tuple{Vector{Float64}, Matrix{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, params}"><code>HANK_MNS.simulate_forward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simulate_forward(D0::Array{Float64,1},cpol_path::Array{Float64,2},Rpath::Array{Float64,1},
                 wpath::Array{Float64,1},div_path::Array{Float64,1},τ_path::Array{Float64,1},p::params)</code></pre><p>Given an initial wealth distribution <code>D0</code>, household policy functions <code>cpol_path</code> and prices for factor prices, taxes and dividends, this function simulates the implied aggregate consumption, labor supply and asset holdings for a transition period.</p><p>Relies on the function <code>aggregate_C_L</code> and <code>forward_dist</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/transition_full.jl#L145-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.simulate_step-Tuple{Vector{Float64}, Matrix{Float64}, Float64, Float64, Float64, Float64, params}" href="#HANK_MNS.simulate_step-Tuple{Vector{Float64}, Matrix{Float64}, Float64, Float64, Float64, Float64, params}"><code>HANK_MNS.simulate_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simulate_step(D::Array{Float64,1},c_pol::Array{Float64,2},R::Float64,w::Float64,
              τ::Float64,div::Float64,p::params)</code></pre><p>Conducts forward simulation for one period. Helper function to simulate<em>forward, equivalent  to simulatestep() in MNS code.Originally used in loop in Simulate</em>forward, replaced it to  do better pre-allocation there.</p><p>Since the function is not used in the final implementation, no more documentation.  (The function is in principle usable though.)</p><p>The following was originally in the simulate forward loop: </p><p><code>Cpath[t], Lpath[t], Bpath[t], Dpath[:,t+1]  = simulate_CLB(Dpath[:,t],reshape_c(cpol_path[:,t],p),Rpath[t],wpath[t],τ_path[t],div_path[t],p)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/transition_full.jl#L188-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.solve_for_transition-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, steady_state, params}" href="#HANK_MNS.solve_for_transition-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, steady_state, params}"><code>HANK_MNS.solve_for_transition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve_for_transition(Rpath::Array{Float64,1},wguess::Array{Float64,1},div_path::Array{Float64,1},
                     Spath::Array{Float64,1},SS::steady_state,p::params,S_tol::Float64=1e-6,w_tol::Float64=1e-6)</code></pre><p>Solves for the perfect foresight transition path for a given interest interest rate path <code>Rpath</code>, assuming that the economy will be back in  steady state as of the final entry of <code>Rpath</code>.</p><p>The other <code>_path</code> inputs constitue initial guesses.</p><p>Given initial guesses, the function applies an iterative procedure to solve for the equilibrium transition path of wages and price dispersion. Specifically, it first iteratively solves for a wage path so that, given the current guess for the path of <code>S</code>, output is (approximately) equal to labor supply. By Walras&#39; law, this means that the asset market must be cleared as well.</p><p>Afterwards, the algorithm computes the price dispersion path S implied by the wage and output paths, which will be the guess of S for the next iteration.</p><p>The function relies on the functions <code>solveback</code> and <code>simulate_forward</code>.</p><p>Default tolerance values correspond to the values used for the MNS code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/transition_full.jl#L33-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.solve_for_transition_CompMkts-Tuple{Any, Any, Any, Any, Any, Any, params}" href="#HANK_MNS.solve_for_transition_CompMkts-Tuple{Any, Any, Any, Any, Any, Any, params}"><code>HANK_MNS.solve_for_transition_CompMkts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve_for_transition_CompMkts(Rpath, wagepath, dividendpath, Spath, stst, name, p::params)</code></pre><p>Solves for the complete markets transition path for a given interest rate path, wpage path, dividend path, etc. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/complete_markets.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HANK_MNS.solveback-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Array{Float64, N} where N, Vector{Float64}, Float64, params}" href="#HANK_MNS.solveback-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Array{Float64, N} where N, Vector{Float64}, Float64, params}"><code>HANK_MNS.solveback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solveback(c_final::Array{Float64,1},w_path::Array{Float64,1},R_path::Array{Float64,1},
          τ_path::Array{Float64},div_path::Array{Float64,1},β::Float64,p::params)</code></pre><p>Solves household problem backwards from a period in which HH policy functions are know (e.g. steady state),  for given time paths of factor prices, taxes and dividends, using the Endogenous Grid Method (EGM).</p><p>It is also used for computing the steady state policy function, for which <code>c_final</code> would be the current guess for the policy function and for which it iterates <code>T</code> (length of <code>w_path</code>) times over the policy function.  </p><p>This function is used in <code>EGM_SS</code> as well as <code>solve_for transition</code>  and calls the function <code>EGM</code> for conducting an individual EGM step.</p><p>In the supplied objects <code>w_path</code>, <code>τ_path</code> etc., the final values must correspond to the period to solve back from, e.g. the steady state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/000martin/HANK_MNS.jl/blob/6861b5511e2b52ed8ff989b4ef9da923b50503d1/src/steady_state.jl#L193-L207">source</a></section></article><p>end</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 20 May 2021 19:14">Thursday 20 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
